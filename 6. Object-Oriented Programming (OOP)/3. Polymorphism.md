## Polymorphism in Kotlin â€“ Types Explained (with Diagram)

* Polymorphism means "many forms", allowing the same function name or operation to behave differently based on the object or data it is acting on.
* In Kotlin (and other object-oriented languages), polymorphism is mainly divided into two types:

## ðŸ“Š Diagram: Types of Polymorphism
pgsql
               Polymorphism
                   |
        -------------------------
        |                       |
   Compile Time             Run Time
     |     \                    |
     |      \                   |
Function   Operator        Virtual
Overloading Overloading    Functions

---

## ðŸ§± 1. Compile-Time Polymorphism

Also called Static Polymorphism. This type of polymorphism is resolved at compile time.

---

* âœ… Function Overloading
* Creating multiple functions with the same name but different parameters (number, type, or order).

```kotlin
fun greet(name: String) {
    println("Hello $name!")
}

fun greet(name: String, time: String) {
    println("Good $time, $name!")
}
```

---

* âœ… Operator Overloading
* You can customize how operators behave for your own classes.
```kotlin
data class Point(val x: Int, val y: Int) {
    operator fun plus(other: Point): Point {
        return Point(x + other.x, y + other.y)
    }
}

val p1 = Point(2, 3)
val p2 = Point(4, 1)
val result = p1 + p2   // Calls the overloaded '+' operator
```

---

## ðŸš€ 2. Run-Time Polymorphism
* Also called Dynamic Polymorphism. Itâ€™s resolved while the program is running.

* âœ… Virtual Functions (Method Overriding)
A child class overrides a method of its parent class, and the right method is chosen at runtime.

---

```kotlin
open class Device {
    open fun turnOn() {
        println("Generic device turned on")
    }
}

class Phone : Device() {
    override fun turnOn() {
        println("Phone is now ON ðŸ“±")
    }
}

fun activate(device: Device) {
    device.turnOn()  // Decided at runtime which turnOn() is called
}

fun main() {
    val myPhone = Phone()
    activate(myPhone)  // Calls Phone's version
}
```

---

## ðŸ’¡ Why Polymorphism Matters in Android

* âœ… Clean code with reusable components
* âœ… Easier maintenance when adding new features
* âœ… Useful for handling UI components like View, Fragment, RecyclerView, etc.
* âœ… Key to writing scalable and testable code
